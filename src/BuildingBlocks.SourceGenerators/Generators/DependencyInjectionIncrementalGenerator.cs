using System.Collections.Immutable;
using System.Text;
using BuildingBlocks.SourceGenerators.Providers;
using BuildingBlocks.SourceGenerators.Sources;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

namespace BuildingBlocks.SourceGenerators.Generators
{
    internal class DependencyInjectionIncrementalGenerator : IIncrementalGenerator
    {
        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            context.RegisterPostInitializationOutput(RegisterAttributes);

            var classTargets = context.SyntaxProvider.CreateSyntaxProvider(ClassTargetInjectProvider.Predicate, ClassTargetInjectProvider.Transform)
                .SelectMany((item, cancellationToken) => item)
                .Collect();
            var assmblyTargets = context.CompilationProvider.SelectMany(AssemblyTargetInjectProvider.Transform).Collect();
            context.RegisterSourceOutput(classTargets.Combine(assmblyTargets), RegisterServices);
        }

        private static void RegisterAttributes(IncrementalGeneratorPostInitializationContext context)
        {
            context.AddSource("HostedServiceAttribute.g.cs", SourceText.From(@"// <auto-generated />

namespace Microsoft.Extensions.DependencyInjection.Attributes
{
    [AttributeUsage(AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
    public sealed class HostedServiceAttribute : Attribute
    {
    }

    [AttributeUsage(AttributeTargets.Assembly, AllowMultiple = true, Inherited = false)]
    public sealed class HostedServiceAttribute<TService> : Attribute
    {
    }
}", Encoding.UTF8));

            context.AddSource("ServiceAttribute.g.cs", SourceText.From(@"// <auto-generated />

namespace Microsoft.Extensions.DependencyInjection.Attributes
{
    [AttributeUsage(AttributeTargets.Assembly | AttributeTargets.Class, AllowMultiple = true, Inherited = false)]
    public abstract class ServiceAttribute(ServiceLifetime lifetime, Type? serviceType = null, 
        Type? implementationType = null, string? key = null, bool isEnumerable = false) : Attribute
    {
        public ServiceLifetime Lifetime { get; } = lifetime;

        public Type? ServiceType { get; } = serviceType;

        public Type? ImplementationType { get; } = implementationType;

        public string? Key { get; } = key;

        public bool IsEnumerable { get; } = isEnumerable;
    }
}", Encoding.UTF8));

            context.AddSource("SingletonAttribute.g.cs", SourceText.From(@"// <auto-generated />

namespace Microsoft.Extensions.DependencyInjection.Attributes
{
    [AttributeUsage(AttributeTargets.Assembly | AttributeTargets.Class, AllowMultiple = true, Inherited = false)]
    public sealed class SingletonAttribute(Type? serviceType = null, Type? implementationType = null,
        string? key = null, bool isEnumerable = false) : ServiceAttribute(ServiceLifetime.Singleton, serviceType, implementationType, key, isEnumerable)
    {
    }

    [AttributeUsage(AttributeTargets.Assembly | AttributeTargets.Class, AllowMultiple = true, Inherited = false)]
    public sealed class SingletonAttribute<TService>(Type? implementationType = null, string? key = null,
        bool isEnumerable = false) : ServiceAttribute(ServiceLifetime.Singleton, typeof(TService), implementationType, key, isEnumerable)
    {
    }

    [AttributeUsage(AttributeTargets.Assembly, AllowMultiple = true, Inherited = false)]
    public sealed class SingletonAttribute<TService, TImplementation>(string? key = null, bool isEnumerable = false)
        : ServiceAttribute(ServiceLifetime.Singleton, typeof(TService), typeof(TImplementation), key, isEnumerable)
        where TImplementation : class, TService
    {
    }
}", Encoding.UTF8));

            context.AddSource("ScopedAttribute.g.cs", SourceText.From(@"// <auto-generated />

namespace Microsoft.Extensions.DependencyInjection.Attributes
{
    [AttributeUsage(AttributeTargets.Assembly | AttributeTargets.Class, AllowMultiple = true, Inherited = false)]
    public sealed class ScopedAttribute(Type? serviceType = null, Type? implementationType = null,
        string? key = null, bool isEnumerable = false) : ServiceAttribute(ServiceLifetime.Scoped, serviceType, implementationType, key, isEnumerable)
    {
    }

    [AttributeUsage(AttributeTargets.Assembly | AttributeTargets.Class, AllowMultiple = true, Inherited = false)]
    public sealed class ScopedAttribute<TService>(Type? implementationType = null, string? key = null,
        bool isEnumerable = false) : ServiceAttribute(ServiceLifetime.Scoped, typeof(TService), implementationType, key, isEnumerable)
    {
    }

    [AttributeUsage(AttributeTargets.Assembly, AllowMultiple = true, Inherited = false)]
    public sealed class ScopedAttribute<TService, TImplementation>(string? key = null, bool isEnumerable = false)
        : ServiceAttribute(ServiceLifetime.Scoped, typeof(TService), typeof(TImplementation), key, isEnumerable)
        where TImplementation : class, TService
    {
    }
}", Encoding.UTF8));

            context.AddSource("TransientAttribute.g.cs", SourceText.From(@"// <auto-generated />

namespace Microsoft.Extensions.DependencyInjection.Attributes
{
    [AttributeUsage(AttributeTargets.Assembly | AttributeTargets.Class, AllowMultiple = true, Inherited = false)]
    public sealed class TransientAttribute(Type? serviceType = null, Type? implementationType = null,
        string? key = null, bool isEnumerable = false) : ServiceAttribute(ServiceLifetime.Transient, serviceType, implementationType, key, isEnumerable)
    {
    }

    [AttributeUsage(AttributeTargets.Assembly | AttributeTargets.Class, AllowMultiple = true, Inherited = false)]
    public sealed class TransientAttribute<TService>(Type? implementationType = null, string? key = null,
        bool isEnumerable = false) : ServiceAttribute(ServiceLifetime.Transient, typeof(TService), implementationType, key, isEnumerable)
    {
    }

    [AttributeUsage(AttributeTargets.Assembly, AllowMultiple = true, Inherited = false)]
    public class TransientAttribute<TService, TImplementation>(string? key = null, bool isEnumerable = false) 
        : ServiceAttribute(ServiceLifetime.Transient, typeof(TService), typeof(TImplementation), key, isEnumerable)
        where TImplementation : class, TService
    {
    }
}", Encoding.UTF8));
        }

        private static void RegisterServices(SourceProductionContext context, (ImmutableArray<DependencyInjectionSource?> Left, ImmutableArray<DependencyInjectionSource?> Right) sources)
        {
            var sourceBuilder = new StringBuilder();
            sourceBuilder.AppendLine(@"// <auto-generated />

using Microsoft.Extensions.DependencyInjection.Extensions;

namespace Microsoft.Extensions.DependencyInjection
{
    public static partial class IServiceCollectionExtensions
    {
        internal static IServiceCollection AddRegisteredServices(this IServiceCollection services)
        {");
            RegisterServices(sourceBuilder, sources.Left, "//<generated-from-class />");
            RegisterServices(sourceBuilder, sources.Right, "//<generated-from-assembly />");
            sourceBuilder.AppendLine(@"            return services;
        }
    }
}");
            context.AddSource("IServiceCollectionExtensions.g.cs", SourceText.From(sourceBuilder.ToString(), Encoding.UTF8));
        }

        private static void RegisterServices(StringBuilder sourceBuilder, ImmutableArray<DependencyInjectionSource?> sources, string postfix)
        {
            foreach (var source in sources)
            {
                if (source is null || source.ServiceName == string.Empty)
                    continue;

                var expression = string.Empty;

                if (source.IsHosted)
                    expression = $"            services.AddHostedService<{source.ServiceName}>();";
                else if (source.IsEnumerable && source.ImplementationName != string.Empty)
                    expression = source.Key == string.Empty ? GetEnumerableServiceExpression(source) : GetKeyedEnumerableServiceExpression(source);
                else
                    expression = source.Key == string.Empty ? GetServiceExpression(source) : GetKeyedServiceExpression(source);

                if (expression != string.Empty)
                    sourceBuilder.AppendLine($"{expression} {postfix}");
            }
        }

        private static string GetKeyedEnumerableServiceExpression(DependencyInjectionSource source)
            => source.Lifetime switch
            {
                0 => $"            services.TryAddEnumerable(ServiceDescriptor.KeyedSingleton(typeof({source.ServiceName}), {source.Key}, typeof({source.ImplementationName})));",
                1 => $"            services.TryAddEnumerable(ServiceDescriptor.KeyedScoped(typeof({source.ServiceName}), {source.Key}, typeof({source.ImplementationName})));",
                2 => $"            services.TryAddEnumerable(ServiceDescriptor.KeyedTransient(typeof({source.ServiceName}), {source.Key}, typeof({source.ImplementationName})));",
                _ => string.Empty
            };

        private static string GetEnumerableServiceExpression(DependencyInjectionSource source)
            => source.Lifetime switch
            {
                0 => $"            services.TryAddEnumerable(ServiceDescriptor.Singleton(typeof({source.ServiceName}), typeof({source.ImplementationName})));",
                1 => $"            services.TryAddEnumerable(ServiceDescriptor.Scoped(typeof({source.ServiceName}), typeof({source.ImplementationName})));",
                2 => $"            services.TryAddEnumerable(ServiceDescriptor.Transient(typeof({source.ServiceName}), typeof({source.ImplementationName})));",
                _ => string.Empty
            };

        private static string GetKeyedServiceExpression(DependencyInjectionSource source)
            => source.Lifetime switch
            {
                0 => source.ImplementationName != string.Empty ?
                $"            services.TryAddKeyedSingleton(typeof({source.ServiceName}), {source.Key}, typeof({source.ImplementationName}));"
                    : $"            services.TryAddKeyedSingleton(typeof({source.ServiceName}), {source.Key});",
                1 => source.ImplementationName != string.Empty ?
                $"            services.TryAddKeyedScoped(typeof({source.ServiceName}), {source.Key}, typeof({source.ImplementationName}));"
                    : $"            services.TryAddKeyedScoped(typeof({source.ServiceName}), {source.Key});",
                2 => source.ImplementationName != string.Empty ?
                $"            services.TryAddKeyedTransient(typeof({source.ServiceName}), {source.Key}, typeof({source.ImplementationName}));"
                    : $"            services.TryAddKeyedTransient(typeof({source.ServiceName}), {source.Key});",
                _ => string.Empty
            };

        private static string GetServiceExpression(DependencyInjectionSource source)
            => source.Lifetime switch
            {
                0 => source.ImplementationName != string.Empty ?
                $"            services.TryAddSingleton(typeof({source.ServiceName}), typeof({source.ImplementationName}));"
                    : $"            services.TryAddSingleton(typeof({source.ServiceName}));",
                1 => source.ImplementationName != string.Empty ?
                $"            services.TryAddScoped(typeof({source.ServiceName}), typeof({source.ImplementationName}));"
                    : $"            services.TryAddScoped(typeof({source.ServiceName}));",
                2 => source.ImplementationName != string.Empty ?
                $"            services.TryAddTransient(typeof({source.ServiceName}), typeof({source.ImplementationName}));"
                    : $"            services.TryAddTransient(typeof({source.ServiceName}));",
                _ => string.Empty
            };
    }
}